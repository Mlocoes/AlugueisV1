from fastapi import APIRouter, HTTPException, Depends, UploadFile, File
from sqlalchemy.orm import Session
from sqlalchemy import func
from typing import List
import pandas as pd
from models_final import Participacion, Propietario, Inmueble
from config import get_db

router = APIRouter(prefix="/participaciones", tags=["participaciones"])

@router.get("/", response_model=dict)
def listar_participaciones(db: Session = Depends(get_db)):
    """Listar participaciones agrupadas por inmueble con columnas dinámicas por propietario"""
    try:
        # Obtener todos los propietarios para crear las columnas
        todos_propietarios = db.query(Propietario).order_by(Propietario.nombre_completo).all()
        
        # Obtener todos los inmuebles con sus participaciones
        inmuebles_con_participaciones = db.query(Inmueble).outerjoin(
            Participacion, Inmueble.id == Participacion.inmueble_id
        ).outerjoin(
            Propietario, Participacion.propietario_id == Propietario.id
        ).order_by(Inmueble.nombre).all()
        
        # Agrupar participaciones por inmueble
        inmuebles_agrupados = {}
        
        for inmueble in inmuebles_con_participaciones:
            if inmueble.id not in inmuebles_agrupados:
                inmuebles_agrupados[inmueble.id] = {
                    "inmueble_id": inmueble.id,
                    "inmueble_nombre": inmueble.nombre,
                    "participaciones_por_propietario": {},
                    "total_porcentaje": 0,
                    "fecha_ultima_actualizacion": None
                }
            
            # Obtener la fecha más reciente de participaciones para este inmueble
            fecha_mas_reciente_subquery = db.query(
                func.max(Participacion.fecha_registro)
            ).filter(
                Participacion.inmueble_id == inmueble.id
            ).scalar()
            
            # Obtener solo las participaciones de la fecha más reciente (vigentes)
            participaciones_inmueble = []
            if fecha_mas_reciente_subquery:
                participaciones_inmueble = db.query(Participacion).filter(
                    Participacion.inmueble_id == inmueble.id,
                    Participacion.fecha_registro == fecha_mas_reciente_subquery
                ).join(Propietario).all()
            
            participaciones_dict = {}
            total_porcentaje = 0
            fecha_mas_reciente = fecha_mas_reciente_subquery
            
            for participacion in participaciones_inmueble:
                participaciones_dict[participacion.propietario_id] = {
                    "propietario_nombre": participacion.propietario.nombre_completo,
                    "porcentaje": float(participacion.porcentaje)
                }
                total_porcentaje += float(participacion.porcentaje)
            
            inmuebles_agrupados[inmueble.id]["participaciones_por_propietario"] = participaciones_dict
            inmuebles_agrupados[inmueble.id]["total_porcentaje"] = total_porcentaje
            inmuebles_agrupados[inmueble.id]["fecha_ultima_actualizacion"] = fecha_mas_reciente.isoformat() if fecha_mas_reciente else None
        
        return {
            "propietarios": [
                {
                    "id": p.id,
                    "nombre_completo": p.nombre_completo
                } for p in todos_propietarios
            ],
            "inmuebles": list(inmuebles_agrupados.values())
        }
        
    except Exception as e:
        import traceback
        print("[ERROR EN /participaciones]", e)
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/", response_model=dict)
def crear_participacion(datos: dict, db: Session = Depends(get_db)):
    """Crear una nueva participación"""
    try:
        # Validar que el propietario existe
        propietario = db.query(Propietario).filter(Propietario.id == datos["propietario_id"]).first()
        if not propietario:
            raise HTTPException(status_code=404, detail="Propietario no encontrado")
        
        # Validar que el inmueble existe
        inmueble = db.query(Inmueble).filter(Inmueble.id == datos["inmueble_id"]).first()
        if not inmueble:
            raise HTTPException(status_code=404, detail="Inmueble no encontrado")
        
        # Validar que no existe una participación duplicada
        participacion_existente = db.query(Participacion).filter(
            Participacion.propietario_id == datos["propietario_id"],
            Participacion.inmueble_id == datos["inmueble_id"]
        ).first()
        if participacion_existente:
            raise HTTPException(
                status_code=400, 
                detail="Ya existe una participación para este propietario en este inmueble"
            )
        
        # Validar porcentaje
        porcentaje = float(datos["porcentaje"])
        if porcentaje <= 0 or porcentaje > 100:
            raise HTTPException(status_code=400, detail="El porcentaje debe estar entre 0.01 y 100")
        
        # Verificar que el total de participaciones no exceda 100%
        total_actual = db.query(Participacion).filter(
            Participacion.inmueble_id == datos["inmueble_id"]
        ).with_entities(db.func.coalesce(db.func.sum(Participacion.porcentaje), 0)).scalar() or 0
        
        if total_actual + porcentaje > 100:
            raise HTTPException(
                status_code=400, 
                detail=f"El porcentaje total excedería 100%. Actual: {total_actual}%, intentando agregar: {porcentaje}%"
            )
        
        # Crear la participación
        p = Participacion(**datos)
        db.add(p)
        db.commit()
        db.refresh(p)
        
        return {
            "id": p.id,
            "propietario_id": p.propietario_id,
            "inmueble_id": p.inmueble_id,
            "porcentaje": float(p.porcentaje),
            "fecha_registro": p.fecha_registro.isoformat() if p.fecha_registro else None,
            "propietario_nombre": propietario.nombre_completo,
            "inmueble_nombre": inmueble.nombre
        }
    except HTTPException:
        raise
    except Exception as e:
        import traceback
        print("[ERROR EN POST /participaciones]", e)
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/{participacion_id}", response_model=dict)
def obtener_participacion(participacion_id: int, db: Session = Depends(get_db)):
    """Obtener una participación específica"""
    p = db.query(Participacion).filter(Participacion.id == participacion_id).first()
    if not p:
        raise HTTPException(status_code=404, detail="Participación no encontrada")
    
    return {
        "id": p.id,
        "propietario_id": p.propietario_id,
        "inmueble_id": p.inmueble_id,
        "porcentaje": float(p.porcentaje),
        "fecha_registro": p.fecha_registro.isoformat() if p.fecha_registro else None,
        "propietario_nombre": p.propietario.nombre_completo,
        "inmueble_nombre": p.inmueble.nombre,
        "inmueble_direccion": p.inmueble.direccion_completa or "Sin dirección"
    }

@router.put("/{participacion_id}", response_model=dict)
def actualizar_participacion(participacion_id: int, datos: dict, db: Session = Depends(get_db)):
    """Actualizar una participación existente"""
    try:
        p = db.query(Participacion).filter(Participacion.id == participacion_id).first()
        if not p:
            raise HTTPException(status_code=404, detail="Participación no encontrada")
        
        # Validar que el propietario existe
        if "propietario_id" in datos:
            propietario = db.query(Propietario).filter(Propietario.id == datos["propietario_id"]).first()
            if not propietario:
                raise HTTPException(status_code=404, detail="Propietario no encontrado")
        
        # Validar que el inmueble existe
        if "inmueble_id" in datos:
            inmueble = db.query(Inmueble).filter(Inmueble.id == datos["inmueble_id"]).first()
            if not inmueble:
                raise HTTPException(status_code=404, detail="Inmueble no encontrado")
        
        # Validar que no se cree una participación duplicada (si se cambian propietario o inmueble)
        nuevo_propietario_id = datos.get("propietario_id", p.propietario_id)
        nuevo_inmueble_id = datos.get("inmueble_id", p.inmueble_id)
        
        if nuevo_propietario_id != p.propietario_id or nuevo_inmueble_id != p.inmueble_id:
            participacion_duplicada = db.query(Participacion).filter(
                Participacion.propietario_id == nuevo_propietario_id,
                Participacion.inmueble_id == nuevo_inmueble_id,
                Participacion.id != participacion_id
            ).first()
            if participacion_duplicada:
                raise HTTPException(
                    status_code=400, 
                    detail="Ya existe una participación para este propietario en este inmueble"
                )
        
        # Validar porcentaje
        if "porcentaje" in datos:
            porcentaje = float(datos["porcentaje"])
            if porcentaje <= 0 or porcentaje > 100:
                raise HTTPException(status_code=400, detail="El porcentaje debe estar entre 0.01 y 100")
            
            # Verificar que el total de participaciones no exceda 100%
            inmueble_id_verificar = nuevo_inmueble_id
            total_actual = db.query(Participacion).filter(
                Participacion.inmueble_id == inmueble_id_verificar,
                Participacion.id != participacion_id
            ).with_entities(db.func.coalesce(db.func.sum(Participacion.porcentaje), 0)).scalar() or 0
            
            if total_actual + porcentaje > 100:
                raise HTTPException(
                    status_code=400, 
                    detail=f"El porcentaje total excedería 100%. Actual (sin esta participación): {total_actual}%, intentando establecer: {porcentaje}%"
                )
        
        # Actualizar campos
        for campo in ["propietario_id", "inmueble_id", "porcentaje"]:
            if campo in datos:
                setattr(p, campo, datos[campo])
        
        db.commit()
        db.refresh(p)
        
        return {
            "id": p.id,
            "propietario_id": p.propietario_id,
            "inmueble_id": p.inmueble_id,
            "porcentaje": float(p.porcentaje),
            "fecha_registro": p.fecha_registro.isoformat() if p.fecha_registro else None,
            "propietario_nombre": p.propietario.nombre_completo,
            "inmueble_nombre": p.inmueble.nombre,
            "inmueble_direccion": p.inmueble.direccion_completa or "Sin dirección"
        }
    except HTTPException:
        raise
    except Exception as e:
        import traceback
        print("[ERROR EN PUT /participaciones]", e)
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))

@router.put("/inmueble/{inmueble_id}/actualizar-participaciones", response_model=dict)
def actualizar_participaciones_inmueble(inmueble_id: int, datos: dict, db: Session = Depends(get_db)):
    """
    Actualizar todas las participaciones de un inmueble de una vez
    datos = {
        "participaciones": [
            {"propietario_id": 1, "porcentaje": 60.0},
            {"propietario_id": 2, "porcentaje": 40.0}
        ]
    }
    """
    try:
        # Verificar que el inmueble existe
        inmueble = db.query(Inmueble).filter(Inmueble.id == inmueble_id).first()
        if not inmueble:
            raise HTTPException(status_code=404, detail="Inmueble no encontrado")
        
        participaciones_nuevas = datos.get("participaciones", [])
        
        # Validar que la suma de porcentajes sea 100%
        total_porcentaje = sum(float(p["porcentaje"]) for p in participaciones_nuevas)
        if abs(total_porcentaje - 100.0) > 0.01:  # Permitir pequeña diferencia por decimales
            raise HTTPException(
                status_code=400, 
                detail=f"La suma de porcentajes debe ser 100%. Actual: {total_porcentaje}%"
            )
        
        # Validar que todos los propietarios existen
        propietarios_ids = [p["propietario_id"] for p in participaciones_nuevas]
        propietarios_existentes = db.query(Propietario).filter(
            Propietario.id.in_(propietarios_ids)
        ).count()
        
        if propietarios_existentes != len(propietarios_ids):
            raise HTTPException(status_code=400, detail="Uno o más propietarios no existen")
        
        # NO eliminar participaciones existentes - mantener historial
        # Solo crear nuevas participaciones con fecha actual
        from datetime import datetime
        fecha_actual = datetime.now()
        
        participaciones_creadas = []
        for participacion_data in participaciones_nuevas:
            if float(participacion_data["porcentaje"]) > 0:  # Solo crear si el porcentaje es mayor que 0
                nueva_participacion = Participacion(
                    propietario_id=participacion_data["propietario_id"],
                    inmueble_id=inmueble_id,
                    porcentaje=float(participacion_data["porcentaje"]),
                    fecha_registro=fecha_actual
                )
                db.add(nueva_participacion)
                participaciones_creadas.append(nueva_participacion)
        
        db.commit()
        
        # Refrescar para obtener los datos completos
        for p in participaciones_creadas:
            db.refresh(p)
        
        return {
            "mensaje": "Participaciones actualizadas correctamente",
            "inmueble_id": inmueble_id,
            "inmueble_nombre": inmueble.nombre,
            "total_participaciones": len(participaciones_creadas),
            "fecha_actualizacion": fecha_actual.isoformat(),
            "participaciones": [
                {
                    "propietario_id": p.propietario_id,
                    "propietario_nombre": p.propietario.nombre_completo,
                    "porcentaje": float(p.porcentaje)
                } for p in participaciones_creadas
            ]
        }
        
    except HTTPException:
        raise
    except Exception as e:
        import traceback
        print("[ERROR EN PUT /participaciones/inmueble/{inmueble_id}/actualizar-participaciones]", e)
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/inmueble/{inmueble_id}", response_model=dict)
def listar_participaciones_por_inmueble(inmueble_id: int, db: Session = Depends(get_db)):
    """Listar todas las participaciones vigentes de un inmueble específico"""
    # Verificar que el inmueble existe
    inmueble = db.query(Inmueble).filter(Inmueble.id == inmueble_id).first()
    if not inmueble:
        raise HTTPException(status_code=404, detail="Inmueble no encontrado")
    
    # Obtener la fecha más reciente de participaciones para este inmueble
    fecha_mas_reciente = db.query(
        func.max(Participacion.fecha_registro)
    ).filter(
        Participacion.inmueble_id == inmueble_id
    ).scalar()
    
    # Obtener solo las participaciones de la fecha más reciente (vigentes)
    participaciones = []
    if fecha_mas_reciente:
        participaciones = db.query(Participacion).filter(
            Participacion.inmueble_id == inmueble_id,
            Participacion.fecha_registro == fecha_mas_reciente
        ).join(Propietario).order_by(Propietario.nombre_completo).all()
    
    total_porcentaje = sum(float(p.porcentaje) for p in participaciones)
    
    return {
        "inmueble_id": inmueble_id,
        "inmueble_nombre": inmueble.nombre,
        "total_porcentaje": total_porcentaje,
        "participaciones": [
            {
                "id": p.id,
                "propietario_id": p.propietario_id,
                "porcentaje": float(p.porcentaje),
                "propietario_nombre": p.propietario.nombre_completo
            } for p in participaciones
        ]
    }

@router.get("/propietario/{propietario_id}", response_model=dict)
def listar_participaciones_por_propietario(propietario_id: int, db: Session = Depends(get_db)):
    """Listar todas las participaciones de un propietario específico"""
    # Verificar que el propietario existe
    propietario = db.query(Propietario).filter(Propietario.id == propietario_id).first()
    if not propietario:
        raise HTTPException(status_code=404, detail="Propietario no encontrado")
    
    participaciones = db.query(Participacion).filter(
        Participacion.propietario_id == propietario_id
    ).join(Inmueble).order_by(Inmueble.nombre).all()
    
    return {
        "propietario_id": propietario_id,
        "propietario_nombre": propietario.nombre_completo,
        "participaciones": [
            {
                "id": p.id,
                "inmueble_id": p.inmueble_id,
                "porcentaje": float(p.porcentaje),
                "inmueble_nombre": p.inmueble.nombre,
                "inmueble_direccion": p.inmueble.direccion_completa or "Sin dirección"
            } for p in participaciones
        ]
    }

@router.get("/inmueble/{inmueble_id}/historial", response_model=dict)
def obtener_historial_participaciones_inmueble(inmueble_id: int, db: Session = Depends(get_db)):
    """Obtener el historial completo de participaciones de un inmueble"""
    # Verificar que el inmueble existe
    inmueble = db.query(Inmueble).filter(Inmueble.id == inmueble_id).first()
    if not inmueble:
        raise HTTPException(status_code=404, detail="Inmueble no encontrado")
    
    # Obtener todas las participaciones históricas ordenadas por fecha (más reciente primero)
    participaciones_historicas = db.query(Participacion).filter(
        Participacion.inmueble_id == inmueble_id
    ).join(Propietario).order_by(
        Participacion.fecha_registro.desc(),
        Propietario.nombre_completo
    ).all()
    
    # Agrupar por fecha
    historial_por_fecha = {}
    for participacion in participaciones_historicas:
        fecha_key = participacion.fecha_registro.isoformat()
        if fecha_key not in historial_por_fecha:
            historial_por_fecha[fecha_key] = {
                "fecha_registro": fecha_key,
                "participaciones": [],
                "total_porcentaje": 0
            }
        
        historial_por_fecha[fecha_key]["participaciones"].append({
            "id": participacion.id,
            "propietario_id": participacion.propietario_id,
            "propietario_nombre": participacion.propietario.nombre_completo,
            "porcentaje": float(participacion.porcentaje)
        })
        historial_por_fecha[fecha_key]["total_porcentaje"] += float(participacion.porcentaje)
    
    return {
        "inmueble_id": inmueble_id,
        "inmueble_nombre": inmueble.nombre,
        "historial": list(historial_por_fecha.values())
    }

@router.post("/importar", response_model=dict)
async def importar_participaciones(file: UploadFile = File(...), db: Session = Depends(get_db)):
    """Importar participaciones desde archivo Excel según ModeloParticipaciones.xlsx"""
    import pandas as pd
    from datetime import datetime
    from fastapi import UploadFile, File
    
    if not file.filename.endswith(('.xlsx', '.xls')):
        raise HTTPException(status_code=400, detail="Archivo debe ser Excel (.xlsx o .xls)")
    
    try:
        # Leer archivo Excel
        contenido = await file.read()
        df = pd.read_excel(contenido)
        
        # Limpiar nombres de columnas (quitar espacios en blanco)
        df.columns = df.columns.str.strip()
        
        # Estructura del Excel:
        # Columna 0: Nombre del inmueble (usar)
        # Columna 1: Dirección (ignorar)
        # Columna 2: Valor (ignorar)
        # Columnas 3+: Propietarios (nombre en header, participación en datos)
        
        if len(df.columns) < 4:
            raise HTTPException(
                status_code=400,
                detail=f"El archivo debe tener al menos 4 columnas. Columnas encontradas: {list(df.columns)}"
            )
        
        # La primera columna es el nombre del inmueble
        columna_inmueble = df.columns[0]
        
        # Las columnas de propietarios empiezan desde la 4ta columna (índice 3)
        columnas_propietarios = df.columns[3:]
        
        # Obtener todos los propietarios para mapear por nombre
        propietarios_bd = db.query(Propietario).all()
        propietarios_dict = {}
        for p in propietarios_bd:
            # Crear múltiples formas de buscar el propietario
            nombre_completo = p.nombre_completo.lower().strip() if p.nombre_completo else ""
            nombre_solo = p.nombre.lower().strip() if p.nombre else ""
            
            if nombre_completo:
                propietarios_dict[nombre_completo] = p
            if nombre_solo:
                propietarios_dict[nombre_solo] = p
            
            # También por combinación nombre + apellido
            if p.apellido and nombre_solo:
                nombre_apellido = f"{nombre_solo} {p.apellido.lower().strip()}"
                propietarios_dict[nombre_apellido] = p
        
        procesados = 0
        creados = 0
        errores = []
        
        for index, row in df.iterrows():
            try:
                procesados += 1
                
                # Obtener nombre del inmueble de la primera columna
                nombre_inmueble = str(row[columna_inmueble]).strip()
                if not nombre_inmueble or nombre_inmueble.lower() == 'nan':
                    errores.append(f"Fila {index + 2}: Nombre de inmueble vacío")
                    continue
                
                # Buscar inmueble por nombre
                inmueble = db.query(Inmueble).filter(Inmueble.nombre == nombre_inmueble).first()
                if not inmueble:
                    errores.append(f"Fila {index + 2}: Inmueble '{nombre_inmueble}' no encontrado")
                    continue
                
                # Procesar participaciones de propietarios (columnas 4+)
                participaciones_creadas = 0
                fecha_registro = datetime.now().date()
                
                for col_propietario in columnas_propietarios:
                    valor_participacion = row[col_propietario]
                    
                    # Solo procesar si hay un valor válido
                    if pd.notna(valor_participacion) and str(valor_participacion).strip() != '' and valor_participacion != 0:
                        try:
                            # Convertir porcentaje
                            if isinstance(valor_participacion, str):
                                if valor_participacion.startswith('='):
                                    continue  # Saltar fórmulas
                                porcentaje = float(valor_participacion.replace('%', '').replace(',', '.').strip())
                            else:
                                porcentaje = float(valor_participacion)
                            
                            # Buscar propietario por nombre de columna
                            nombre_propietario = col_propietario.lower().strip()
                            propietario = None
                            
                            # Buscar en el diccionario de propietarios
                            if nombre_propietario in propietarios_dict:
                                propietario = propietarios_dict[nombre_propietario]
                            else:
                                # Búsqueda más flexible
                                for key, prop in propietarios_dict.items():
                                    if nombre_propietario in key or key in nombre_propietario:
                                        propietario = prop
                                        break
                            
                            if not propietario:
                                errores.append(f"Fila {index + 2}: Propietario '{col_propietario}' no encontrado en la base de datos")
                                continue
                            
                            # Verificar si ya existe una participación para este inmueble y propietario
                            participacion_existente = db.query(Participacion).filter(
                                Participacion.inmueble_id == inmueble.id,
                                Participacion.propietario_id == propietario.id
                            ).first()
                            
                            if participacion_existente:
                                # Actualizar participación existente
                                participacion_existente.porcentaje_participacion = porcentaje
                                participacion_existente.fecha_actualizacion = datetime.now()
                            else:
                                # Crear nueva participación
                                nueva_participacion = Participacion(
                                    inmueble_id=inmueble.id,
                                    propietario_id=propietario.id,
                                    porcentaje_participacion=porcentaje,
                                    fecha_inicio=fecha_registro,
                                    activo=True
                                )
                                db.add(nueva_participacion)
                                participaciones_creadas += 1
                            
                        except ValueError as e:
                            errores.append(f"Fila {index + 2}, Propietario '{col_propietario}': Valor de participación inválido '{valor_participacion}'")
                            continue
                        except Exception as e:
                            errores.append(f"Fila {index + 2}, Propietario '{col_propietario}': Error inesperado - {str(e)}")
                            continue
                
                # Commit para este inmueble si se crearon participaciones
                if participaciones_creadas > 0:
                    db.commit()
                    creados += participaciones_creadas
                
            except Exception as e:
                db.rollback()
                errores.append(f"Fila {index + 2}: Error inesperado - {str(e)}")
                continue
        
        # Preparar respuesta
        resultado = {
            "procesados": procesados,
            "creados": creados,
            "errores": len(errores),
            "detalle_errores": errores[:10],  # Limitar a 10 errores para no sobrecargar
            "mensaje": f"Procesados: {procesados}, Creados: {creados}, Errores: {len(errores)}"
        }
        
        return resultado
        
    except Exception as e:
        db.rollback()
        import traceback
        print(f"Error en importación de participaciones: {traceback.format_exc()}")
        raise HTTPException(status_code=500, detail=f"Error al procesar archivo: {str(e)}")
        
    except Exception as e:
        db.rollback()
        import traceback
        print(f"Error en importación de participaciones: {traceback.format_exc()}")
        raise HTTPException(status_code=500, detail=f"Error al procesar archivo: {str(e)}")
