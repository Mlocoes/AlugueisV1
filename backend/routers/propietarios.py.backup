from fastapi import APIRouter, HTTPException, Depends, UploadFile, File
from sqlalchemy.orm import Session
from typing import List
import pandas as pd
import traceback
from datetime import datetime
from models_final import Propietario
from config import get_db

router = APIRouter(prefix="/propietarios", tags=["propietarios"])

@router.get("/")
def listar_propietarios(db: Session = Depends(get_db)):
    try:
        propietarios = db.query(Propietario).order_by(Propietario.nombre).all()
        data = [
            {
                "id": p.id,
                "nombre": p.nombre,
                "apellido": p.apellido,
                "nombre_completo": p.nombre_completo,
                "documento": p.documento,
                "tipo_documento": p.tipo_documento,
                "direccion": p.direccion,
                "banco": p.banco,
                "agencia": p.agencia,
                "cuenta": p.cuenta,
                "tipo_cuenta": p.tipo_cuenta,
                "telefono": p.telefono,
                "email": p.email,
                "activo": p.activo
            } for p in propietarios
        ]
        return {"success": True, "data": data}
    except Exception as e:
        import traceback
        print("[ERROR EN /propietarios]", e)
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/", response_model=dict)
def crear_propietario(datos: dict, db: Session = Depends(get_db)):
    # Generar nombre_completo si no se proporciona
    if not datos.get('nombre_completo') and datos.get('nombre') and datos.get('apellido'):
        datos['nombre_completo'] = f"{datos['nombre']} {datos['apellido']}"
    
    p = Propietario(**datos)
    db.add(p)
    db.commit()
    db.refresh(p)
    return {
        "id": p.id,
        "nombre": p.nombre,
        "apellido": p.apellido,
        "nombre_completo": p.nombre_completo,
        "documento": p.documento,
        "tipo_documento": p.tipo_documento,
        "direccion": p.direccion,
        "banco": p.banco,
        "agencia": p.agencia,
        "cuenta": p.cuenta,
        "tipo_cuenta": p.tipo_cuenta,
        "telefono": p.telefono,
        "email": p.email,
        "activo": p.activo
    }

@router.get("/{propietario_id}", response_model=dict)
def obtener_propietario(propietario_id: int, db: Session = Depends(get_db)):
    p = db.query(Propietario).filter(Propietario.id == propietario_id).first()
    if not p:
        raise HTTPException(status_code=404, detail="Propietario no encontrado")
    return {
        "id": p.id,
        "nombre": p.nombre,
        "apellido": p.apellido,
        "nombre_completo": p.nombre_completo,
        "documento": p.documento,
        "tipo_documento": p.tipo_documento,
        "direccion": p.direccion,
        "banco": p.banco,
        "agencia": p.agencia,
        "cuenta": p.cuenta,
        "tipo_cuenta": p.tipo_cuenta,
        "telefono": p.telefono,
        "email": p.email,
        "activo": p.activo
    }

@router.put("/{propietario_id}", response_model=dict)
def actualizar_propietario(propietario_id: int, datos: dict, db: Session = Depends(get_db)):
    p = db.query(Propietario).filter(Propietario.id == propietario_id).first()
    if not p:
        raise HTTPException(status_code=404, detail="Propietario no encontrado")
    
    # Actualizar nombre_completo si se cambia nombre o apellido
    if 'nombre' in datos or 'apellido' in datos:
        nombre = datos.get('nombre', p.nombre)
        apellido = datos.get('apellido', p.apellido)
        if nombre and apellido:
            datos['nombre_completo'] = f"{nombre} {apellido}"
    
    for campo in [
        "nombre", "apellido", "nombre_completo", "documento", "tipo_documento", "direccion",
        "banco", "agencia", "cuenta", "tipo_cuenta", "telefono", "email", "activo"
    ]:
        if campo in datos:
            setattr(p, campo, datos[campo])
    db.commit()
    db.refresh(p)
    return {
        "id": p.id,
        "nombre": p.nombre,
        "apellido": p.apellido,
        "nombre_completo": p.nombre_completo,
        "documento": p.documento,
        "tipo_documento": p.tipo_documento,
        "direccion": p.direccion,
        "banco": p.banco,
        "agencia": p.agencia,
        "cuenta": p.cuenta,
        "tipo_cuenta": p.tipo_cuenta,
        "telefono": p.telefono,
        "email": p.email,
        "activo": p.activo
    }

@router.delete("/{propietario_id}", response_model=dict)
def eliminar_propietario(propietario_id: int, db: Session = Depends(get_db)):
    try:
        # Importar aquí para evitar importaciones circulares
        from models_final import AlquilerSimple
        
        # Verificar si el propietario existe
        p = db.query(Propietario).filter(Propietario.id == propietario_id).first()
        if not p:
            raise HTTPException(status_code=404, detail="Propietario no encontrado")
        
        # Verificar si tiene alquileres asociados
        alquileres_count = db.query(AlquilerSimple).filter(AlquilerSimple.propietario_id == propietario_id).count()
        if alquileres_count > 0:
            raise HTTPException(
                status_code=400, 
                detail=f"No se puede eliminar el propietario porque tiene {alquileres_count} alquiler(es) asociado(s). Elimine primero los alquileres o desactive el propietario."
            )
        
        # Si no hay alquileres, proceder con la eliminación
        db.delete(p)
        db.commit()
        return {"success": True, "mensaje": "Propietario eliminado correctamente"}
        
    except HTTPException:
        raise
    except Exception as e:
        db.rollback()
        import traceback
        print(f"Error eliminando propietario {propietario_id}: {str(e)}")
        print(traceback.format_exc())
        raise HTTPException(status_code=500, detail=f"Error interno del servidor: {str(e)}")

@router.post("/importar", response_model=dict)
async def importar_propietarios(file: UploadFile = File(...), db: Session = Depends(get_db)):
    """Importar propietarios desde archivo Excel o CSV según ModeloPropietarios.xlsx"""
    if not file.filename.endswith(('.xlsx', '.xls', '.csv')):
        raise HTTPException(status_code=400, detail="Archivo debe ser Excel (.xlsx, .xls) o CSV (.csv)")
    
    inicio_tiempo = datetime.now()
    
    try:
        # Leer archivo
        contenido = await file.read()
        
        if file.filename.endswith('.csv'):
            # Intentar diferentes encodings para CSV
            for encoding in ['utf-8', 'latin-1', 'cp1252']:
                try:
                    import io
                    df = pd.read_csv(io.StringIO(contenido.decode(encoding)))
                    break
                except UnicodeDecodeError:
                    continue
            else:
                raise HTTPException(status_code=400, detail="No se pudo leer el archivo CSV. Verifique la codificación.")
        else:
            df = pd.read_excel(contenido)
        
        # Mapeo exacto según ModeloPropietarios.xlsx
        mapeo_columnas = {
            'Nombre': 'nombre',
            'Apellido': 'apellido', 
            'Documento': 'documento',
            'Tipo Documento': 'tipo_documento',
            'Dirección': 'direccion',
            'Teléfono': 'telefono',
            'Banco': 'banco',
            'Agencia': 'agencia',
            'Cuenta': 'cuenta',
            'Tipo Cuenta': 'tipo_cuenta'
        }
        
        # Verificar que existe la columna obligatoria
        if 'Nombre' not in df.columns:
            raise HTTPException(
                status_code=400,
                detail=f"Columna 'Nombre' requerida no encontrada. Columnas disponibles: {list(df.columns)}"
            )
        
        registros_procesados = 0
        registros_creados = 0
        registros_errores = 0
        errores_detalle = []
        
        for indice, fila in df.iterrows():
            registros_procesados += 1
            
            try:
                # Convertir fila usando el mapeo exacto de columnas
                datos_propietario = {}
                
                for col_excel, col_bd in mapeo_columnas.items():
                    if col_excel in df.columns:
                        valor = fila[col_excel]
                        if pd.notna(valor) and str(valor).strip() != '':
                            datos_propietario[col_bd] = str(valor).strip()
                
                # Verificar que tenga al menos nombre
                if 'nombre' not in datos_propietario or not datos_propietario['nombre']:
                    errores_detalle.append(f"Fila {indice + 2}: Falta el nombre del propietario")
                    registros_errores += 1
                    continue
                
                # Generar nombre_completo automáticamente
                nombre = datos_propietario.get('nombre', '')
                apellido = datos_propietario.get('apellido', '')
                if nombre and apellido:
                    datos_propietario['nombre_completo'] = f"{nombre} {apellido}"
                else:
                    datos_propietario['nombre_completo'] = nombre
                
                # Verificar si ya existe un propietario con el mismo nombre completo
                propietario_existente = db.query(Propietario).filter(
                    Propietario.nombre_completo == datos_propietario['nombre_completo']
                ).first()
                
                if propietario_existente:
                    errores_detalle.append(f"Fila {indice + 2}: Ya existe un propietario con el nombre '{datos_propietario['nombre_completo']}'")
                    registros_errores += 1
                    continue
                
                # Crear propietario
                nuevo_propietario = Propietario(**datos_propietario)
                db.add(nuevo_propietario)
                db.commit()
                db.refresh(nuevo_propietario)
                
                registros_creados += 1
                
            except Exception as e:
                db.rollback()
                errores_detalle.append(f"Fila {indice + 2}: {str(e)}")
                registros_errores += 1
                continue
        
        # Preparar respuesta
        resultado = {
            "procesados": registros_procesados,
            "creados": registros_creados,
            "errores": registros_errores,
            "detalle_errores": errores_detalle[:10],  # Limitar a 10 errores
            "mensaje": f"Procesados: {registros_procesados}, Creados: {registros_creados}, Errores: {registros_errores}",
            "tiempo_procesamiento": str(datetime.now() - inicio_tiempo)
        }
        
        return resultado
        
    except Exception as e:
        db.rollback()
        import traceback
        print(f"Error en importación de propietarios: {traceback.format_exc()}")
        raise HTTPException(status_code=500, detail=f"Error al procesar archivo: {str(e)}")

        
        # Commit final
        if registros_creados > 0:
            db.commit()
        
        fin_tiempo = datetime.now()
        tiempo_procesamiento = (fin_tiempo - inicio_tiempo).total_seconds()
        
        resultado = {
            "mensaje": "Importación completada",
            "archivo": file.filename,
            "procesados": registros_procesados,
            "creados": registros_creados,
            "errores": registros_errores,
            "tiempo_procesamiento": f"{tiempo_procesamiento:.2f} segundos",
            "detalles_errores": errores_detalle[:10]  # Mostrar solo los primeros 10 errores
        }
        
        if registros_errores > 0 and registros_creados == 0:
            resultado["mensaje"] = "Importación fallida - No se crearon registros"
        elif registros_errores > 0:
            resultado["mensaje"] = "Importación parcial - Algunos registros fallaron"
        else:
            resultado["mensaje"] = "Importación exitosa - Todos los registros procesados"
        
        return resultado
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"Error general en importación: {e}")
        traceback.print_exc()
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Error procesando archivo: {str(e)}")
