"""
Router para endpoints de alquileres
"""
from datetime import datetime
from typing import List, Optional
from fastapi import APIRouter, HTTPException, Query, Depends
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_, desc, asc, func

from config import get_db
from models_final import AluguelSimples, ValidadorAluguelSimples, Imovel, Proprietario
from services.calculo_service import CalculoService
from utils.helpers import limpiar_nombre_propiedad, formatear_periodo_label

router = APIRouter(prefix="/alquileres", tags=["alquileres"])

@router.get("/", response_model=List[dict])
async def listar_alquileres(
    skip: int = Query(0, ge=0, description="Registros a omitir"),
    limit: int = Query(100, ge=1, le=1000, description="L칤mite de registros"),
    ano: Optional[int] = Query(None, description="Filtrar por a침o"),
    mes: Optional[int] = Query(None, ge=1, le=12, description="Filtrar por mes"),
    inmueble_id: Optional[int] = Query(None, description="Filtrar por ID de inmueble"),
    propietario_id: Optional[int] = Query(None, description="Filtrar por ID de propietario"),
    orden: str = Query("desc", description="Orden: asc o desc"),
    db: Session = Depends(get_db)
):
    """Listar alquileres con filtros y paginaci칩n"""
    try:
        query = db.query(AlquilerSimple)
        
        # Aplicar filtros
        if ano:
            query = query.filter(AlquilerSimple.ano == ano)
        if mes:
            query = query.filter(AlquilerSimple.mes == mes)
        if inmueble_id:
            query = query.filter(AlquilerSimple.inmueble_id == inmueble_id)
        if propietario_id:
            query = query.filter(AlquilerSimple.propietario_id == propietario_id)
        
        # Aplicar orden
        if orden.lower() == "asc":
            query = query.order_by(asc(AlquilerSimple.ano), asc(AlquilerSimple.mes), asc(AlquilerSimple.inmueble_id))
        else:
            query = query.order_by(desc(AlquilerSimple.ano), desc(AlquilerSimple.mes), asc(AlquilerSimple.inmueble_id))
        
        # Aplicar paginaci칩n
        alquileres = query.offset(skip).limit(limit).all()
        
        # Devolver tambi칠n nombres relacionados
        return [
            {
                **alquiler.to_dict(),
                'nombre_inmueble': alquiler.inmueble.nombre if alquiler.inmueble else None,
                'nombre_propietario': alquiler.propietario.nombre if alquiler.propietario else None
            }
            for alquiler in alquileres
        ]
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error al listar alquileres: {str(e)}")

@router.get("/anos-disponibles/")
async def obtener_anos_disponibles(db: Session = Depends(get_db)):
    """Obtener lista de a침os que tienen datos de alquileres"""
    try:
        anos = db.query(AlquilerSimple.ano).distinct().order_by(desc(AlquilerSimple.ano)).all()
        anos_lista = [ano[0] for ano in anos if ano[0] is not None]
        
        print(f"游늰 A침os disponibles en datos: {anos_lista}")
        
        return {
            'anos': anos_lista,
            'total': len(anos_lista)
        }
    except Exception as e:
        print(f"Error en /alquileres/anos-disponibles/: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error obteniendo a침os disponibles: {str(e)}")

@router.get("/totales-por-inmueble/")
async def obtener_totales_por_inmueble(
    ano: Optional[int] = Query(None, description="Filtrar por a침o (por defecto 칰ltimo a침o con datos)"),
    mes: Optional[int] = Query(None, ge=1, le=12, description="Filtrar por mes (por defecto 칰ltimo mes con datos)"),
    db: Session = Depends(get_db)
):
    """Obtener totales de alquileres por inmueble para el 칰ltimo mes o per칤odo especificado"""
    try:
        # Si no se especifica a침o/mes, obtener el 칰ltimo per칤odo disponible
        if not ano or not mes:
            ultimo_periodo = db.query(
                AlquilerSimple.ano, 
                AlquilerSimple.mes
            ).order_by(
                desc(AlquilerSimple.ano), 
                desc(AlquilerSimple.mes)
            ).first()
            
            if not ultimo_periodo:
                return []
            
            if not ano:
                ano = ultimo_periodo.ano
            if not mes:
                mes = ultimo_periodo.mes
        
        # Obtener totales agrupados por inmueble para el per칤odo especificado
        resultado = db.query(
            AlquilerSimple.inmueble_id,
            func.sum(AlquilerSimple.valor_alquiler_propietario).label('total_valor'),
            func.count(AlquilerSimple.id).label('cantidad_propietarios')
        ).filter(
            AlquilerSimple.ano == ano,
            AlquilerSimple.mes == mes
        ).group_by(
            AlquilerSimple.inmueble_id
        ).order_by(
            desc('total_valor')
        ).all()
        
        # Formatear respuesta
        totales = []
        for row in resultado:
            inmueble = db.query(Inmueble).filter(Inmueble.id == row.inmueble_id).first()
            totales.append({
                'inmueble_id': row.inmueble_id,
                'nombre_inmueble': inmueble.nombre if inmueble else None,
                'total_valor': float(row.total_valor),
                'cantidad_propietarios': int(row.cantidad_propietarios),
                'ano': ano,
                'mes': mes
            })
        
        return {
            'periodo': {'ano': ano, 'mes': mes},
            'totales': totales,
            'total_inmuebles': len(totales)
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error al obtener totales por inmueble: {str(e)}")

@router.get("/totales-por-mes/")
async def obtener_totales_por_mes(
    limite_meses: Optional[int] = Query(12, ge=1, le=24, description="N칰mero de meses a incluir (m치ximo 24)"),
    db: Session = Depends(get_db)
):
    """Obtener totales de alquileres agrupados por mes para el gr치fico de tendencias"""
    try:
        # Obtener todos los per칤odos disponibles ordenados por fecha
        resultado = db.query(
            AlquilerSimple.ano,
            AlquilerSimple.mes,
            func.sum(AlquilerSimple.valor_alquiler_propietario).label('total_mes'),
            func.count(AlquilerSimple.id).label('cantidad_alquileres')
        ).group_by(
            AlquilerSimple.ano,
            AlquilerSimple.mes
        ).order_by(
            desc(AlquilerSimple.ano),
            desc(AlquilerSimple.mes)
        ).limit(limite_meses).all()
        
        if not resultado:
            return {
                'totales_mensuales': [],
                'total_periodos': 0
            }
        
        # Formatear respuesta y invertir orden para mostrar cronol칩gicamente
        totales_mensuales = []
        for row in reversed(resultado):
            periodo_label = formatear_periodo_label(row.ano, row.mes)
            
            totales_mensuales.append({
                'ano': row.ano,
                'mes': row.mes,
                'periodo': periodo_label,
                'total_valor': float(row.total_mes),
                'cantidad_alquileres': int(row.cantidad_alquileres)
            })
        
        return {
            'totales_mensuales': totales_mensuales,
            'total_periodos': len(totales_mensuales)
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error al obtener totales por mes: {str(e)}")

@router.get("/distribucion-matriz/")
async def obtener_distribucion_matriz(
    ano: Optional[int] = Query(None, description="Filtrar por a침o (por defecto 칰ltimo a침o con datos)"),
    mes: Optional[int] = Query(None, ge=1, le=12, description="Filtrar por mes (por defecto 칰ltimo mes con datos)"),
    propietario_id: Optional[int] = Query(None, description="Filtrar por ID de propietario espec칤fico"),
    agregacion: Optional[str] = Query("mes_especifico", description="Tipo de agregaci칩n: 'mes_especifico', 'ano_completo', 'completo'"),
    db: Session = Depends(get_db)
):
    """Obtener distribuci칩n de alquileres en formato matriz (propietarios vs inmuebles) con agregaci칩n seg칰n filtros"""
    try:
        print(f"游댌 Distribuci칩n matriz solicitada - A침o: {ano}, Mes: {mes}, Propietario: {propietario_id}, Agregaci칩n: {agregacion}")
        
        # Determinar qu칠 filtros aplicar seg칰n el tipo de agregaci칩n
        if agregacion == "completo":
            # Sin filtros de a침o/mes - todos los datos
            print("游늵 Agregaci칩n completa: sumando todos los per칤odos disponibles")
            ano_filtro = None
            mes_filtro = None
        elif agregacion == "ano_completo" and ano:
            # Solo filtrar por a침o - sumar todos los meses del a침o
            print(f"游늵 Agregaci칩n anual: sumando todos los meses del a침o {ano}")
            ano_filtro = ano
            mes_filtro = None
        else:
            # Mes espec칤fico o valor por defecto
            if not ano or not mes:
                ultimo_periodo = db.query(
                    AlquilerSimple.ano, 
                    AlquilerSimple.mes
                ).order_by(
                    desc(AlquilerSimple.ano), 
                    desc(AlquilerSimple.mes)
                ).first()
                
                if not ultimo_periodo:
                    return {
                        'periodo': {'ano': None, 'mes': None, 'tipo_agregacion': agregacion},
                        'propietarios': [],
                        'inmuebles': [],
                        'matriz': []
                    }
                
                if not ano:
                    ano = ultimo_periodo.ano
                if not mes:
                    mes = ultimo_periodo.mes
            
            print(f"游늵 Mes espec칤fico: {mes}/{ano}")
            ano_filtro = ano
            mes_filtro = mes

        # Obtener todos los alquileres seg칰n el tipo de agregaci칩n
        query = db.query(AlquilerSimple)
        
        # Aplicar filtros de per칤odo seg칰n agregaci칩n
        if ano_filtro and mes_filtro:
            # Mes espec칤fico
            query = query.filter(
                AlquilerSimple.ano == ano_filtro,
                AlquilerSimple.mes == mes_filtro
            )
            periodo_texto = f"{mes_filtro}/{ano_filtro}"
        elif ano_filtro:
            # A침o completo
            query = query.filter(AlquilerSimple.ano == ano_filtro)
            periodo_texto = f"A침o {ano_filtro}"
        else:
            # Sin filtros de per칤odo - todos los datos
            periodo_texto = "Todos los per칤odos"
        
        # Aplicar filtro de propietario si se especifica
        if propietario_id:
            query = query.filter(AlquilerSimple.propietario_id == propietario_id)
            print(f"游늵 Filtro de propietario aplicado: {propietario_id}")
            
        alquileres = query.all()
        print(f"游늵 Alquileres encontrados para {periodo_texto}: {len(alquileres)}")

        if not alquileres:
            return {
                'periodo': {'ano': ano_filtro, 'mes': mes_filtro, 'tipo_agregacion': agregacion, 'descripcion': periodo_texto},
                'propietarios': [],
                'inmuebles': [],
                'matriz': []
            }

        # Obtener listas 칰nicas de propietarios e inmuebles
        propietarios = sorted(list(set(alq.propietario_id for alq in alquileres)))
        inmuebles = sorted(list(set(alq.inmueble_id for alq in alquileres)))

        # Crear matriz de distribuci칩n con sumatoria
        matriz = []
        for propietario_id in propietarios:
            propietario = db.query(Propietario).filter(Propietario.id == propietario_id).first()
            fila = {
                'propietario_id': propietario_id,
                'nombre_propietario': propietario.nombre if propietario else None,
                'valores': {},
                'total': 0
            }
            alquileres_propietario = [alq for alq in alquileres if alq.propietario_id == propietario_id]
            for inmueble_id in inmuebles:
                inmueble = db.query(Inmueble).filter(Inmueble.id == inmueble_id).first()
                alquileres_inmueble = [alq for alq in alquileres_propietario if alq.inmueble_id == inmueble_id]
                valor_total = sum(float(alq.valor_alquiler_propietario) for alq in alquileres_inmueble)
                fila['valores'][inmueble.nombre if inmueble else str(inmueble_id)] = valor_total
                fila['total'] += valor_total
            matriz.append(fila)

        # Informaci칩n adicional sobre la agregaci칩n
        total_registros = len(alquileres)
        periodos_unicos = list(set((alq.ano, alq.mes) for alq in alquileres))
        
        print(f"游늵 Matriz generada: {len(propietarios)} propietarios, {len(inmuebles)} inmuebles")
        print(f"游늵 Total registros procesados: {total_registros} de {len(periodos_unicos)} per칤odo(s)")

        return {
            'periodo': {
                'ano': ano_filtro, 
                'mes': mes_filtro, 
                'tipo_agregacion': agregacion, 
                'descripcion': periodo_texto,
                'total_registros': total_registros,
                'periodos_incluidos': len(periodos_unicos)
            },
        'propietarios': [
            {'propietario_id': pid, 'nombre': db.query(Propietario).filter(Propietario.id == pid).first().nombre if db.query(Propietario).filter(Propietario.id == pid).first() else None}
            for pid in propietarios
        ],
        'inmuebles': [
            {'inmueble_id': iid, 'nombre': db.query(Inmueble).filter(Inmueble.id == iid).first().nombre if db.query(Inmueble).filter(Inmueble.id == iid).first() else None}
            for iid in inmuebles
        ],
            'matriz': matriz,
            'total_propietarios': len(propietarios),
            'total_inmuebles': len(inmuebles)
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error al obtener distribuci칩n matriz: {str(e)}")

@router.get("/{alquiler_id}")
async def obtener_alquiler(alquiler_id: int, db: Session = Depends(get_db)):
    """Obtener un alquiler espec칤fico por ID"""
    alquiler = db.query(AlquilerSimple).filter(AlquilerSimple.id == alquiler_id).first()
    if not alquiler:
        raise HTTPException(status_code=404, detail="Alquiler no encontrado")
    
    return alquiler.to_dict()

@router.post("/")
async def crear_alquiler(alquiler_data: dict, db: Session = Depends(get_db)):
    """Crear un nuevo registro de alquiler"""
    try:
        # Validar datos
        es_valido, errores = AlquilerSimpleValidator.validar_datos_excel(alquiler_data)
        if not es_valido:
            raise HTTPException(status_code=400, detail={"errores": errores})
        
        # Normalizar datos
        datos_normalizados = AlquilerSimpleValidator.normalizar_nombres(alquiler_data)
        
        # Crear objeto
        nuevo_alquiler = AlquilerSimple(**datos_normalizados)
        
        db.add(nuevo_alquiler)
        db.commit()
        db.refresh(nuevo_alquiler)
        
        return {
            "mensaje": "Alquiler creado exitosamente",
            "alquiler": nuevo_alquiler.to_dict()
        }
        
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Error al crear alquiler: {str(e)}")

@router.put("/{alquiler_id}")
async def actualizar_alquiler(alquiler_id: int, alquiler_data: dict, db: Session = Depends(get_db)):
    """Actualizar un alquiler existente"""
    try:
        alquiler = db.query(AlquilerSimple).filter(AlquilerSimple.id == alquiler_id).first()
        if not alquiler:
            raise HTTPException(status_code=404, detail="Alquiler no encontrado")
        
        # Validar datos
        es_valido, errores = AlquilerSimpleValidator.validar_datos_excel(alquiler_data)
        if not es_valido:
            raise HTTPException(status_code=400, detail={"errores": errores})
        
        # Normalizar datos
        datos_normalizados = AlquilerSimpleValidator.normalizar_nombres(alquiler_data)
        
        # Actualizar campos
        for campo, valor in datos_normalizados.items():
            if hasattr(alquiler, campo):
                setattr(alquiler, campo, valor)
        
        alquiler.fecha_actualizacion = func.current_timestamp()
        
        db.commit()
        db.refresh(alquiler)
        
        return {
            "mensaje": "Alquiler actualizado exitosamente",
            "alquiler": alquiler.to_dict()
        }
        
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Error al actualizar alquiler: {str(e)}")

@router.delete("/{alquiler_id}")
async def eliminar_alquiler(alquiler_id: int, db: Session = Depends(get_db)):
    """Eliminar un alquiler"""
    try:
        alquiler = db.query(AlquilerSimple).filter(AlquilerSimple.id == alquiler_id).first()
        if not alquiler:
            raise HTTPException(status_code=404, detail="Alquiler no encontrado")
        
        db.delete(alquiler)
        db.commit()
        
        return {"mensaje": "Alquiler eliminado exitosamente"}
        
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Error al eliminar alquiler: {str(e)}")

@router.post("/recalcular-tasas/")
async def recalcular_todas_las_tasas(db: Session = Depends(get_db)):
    """Recalcula todas las tasas de administraci칩n por propietario aplicando correctamente las participaciones"""
    try:
        resultado = CalculoService.recalcular_todas_las_tasas(db)
        
        return {
            "mensaje": "Rec치lculo de tasas completado",
            "resumen": resultado,
            "errores": resultado["errores"] if resultado["errores"] else None
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error al recalcular tasas: {str(e)}")
