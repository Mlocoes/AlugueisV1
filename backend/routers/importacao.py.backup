"""
Router para importação de dados via Excel
Compatível com as tabelas atuais do sistema
"""
import os
import pandas as pd
import traceback
from datetime import datetime
from fastapi import APIRouter, HTTPException, UploadFile, File, Query, Depends
from sqlalchemy import and_, desc
from sqlalchemy.orm import Session
from config import get_db
from models_final import AluguelSimples, Proprietario, Imovel

router = APIRouter(tags=["importação"])

@router.post("/importar-excel/")
async def importar_proprietarios_excel(file: UploadFile = File(...), db: Session = Depends(get_db)):
    """Importa proprietários a partir de arquivo Excel compatível com a tabela proprietarios."""
    if not file.filename.endswith((".xlsx", ".xls")):
        raise HTTPException(status_code=400, detail="O arquivo deve ser Excel (.xlsx ou .xls)")
    try:
        contents = await file.read()
        df = pd.read_excel(contents)
        registros_processados = 0
        registros_sucesso = 0
        registros_erros = 0
        erros_detalhe = []
        for indice, fila in df.iterrows():
            registros_processados += 1
            try:
                dados = fila.to_dict()
                novo_proprietario = Proprietario(
                    nome=dados.get('nome', ''),
                    sobrenome=dados.get('sobrenome', ''),
                    documento=dados.get('documento', ''),
                    tipo_documento=dados.get('tipo_documento', ''),
                    endereco=dados.get('endereco', ''),
                    telefone=dados.get('telefone', ''),
                    email=dados.get('email', ''),
                    banco=dados.get('banco', ''),
                    agencia=dados.get('agencia', ''),
                    conta=dados.get('conta', ''),
                    tipo_conta=dados.get('tipo_conta', '')
                )
                db.add(novo_proprietario)
                db.flush()
                registros_sucesso += 1
            except Exception as e:
                registros_erros += 1
                erros_detalhe.append(f"Linha {indice + 2}: Erro - {str(e)}")
        db.commit()
        return {
            "processados": registros_processados,
            "sucesso": registros_sucesso,
            "erros": registros_erros,
            "detalhe_erros": erros_detalhe[:10]
        }
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Erro ao processar arquivo: {str(e)}")

@router.post("/importar-alquileres-modelo/")
async def importar_alugueis_excel(file: UploadFile = File(...), db: Session = Depends(get_db)):
    """Importa aluguéis a partir de arquivo Excel compatível com a tabela alugueis_simples."""
    if not file.filename.endswith((".xlsx", ".xls")):
        raise HTTPException(status_code=400, detail="Arquivo deve ser Excel (.xlsx ou .xls)")
    try:
        conteudo = await file.read()
        df = pd.read_excel(conteudo)
        colunas_esperadas = ["Valor Total", "Taxa de Administração"]
        for col in colunas_esperadas:
            if col not in df.columns:
                raise HTTPException(status_code=400, detail=f"Coluna '{col}' obrigatória não encontrada. Colunas disponíveis: {list(df.columns)}")
        primeira_coluna = df.columns[0]
        proprietarios_bd = db.query(Proprietario).all()
        proprietarios_map = {p.nome.strip().lower(): p for p in proprietarios_bd}
        idx_valor_total = list(df.columns).index("Valor Total")
        idx_taxa_adm = list(df.columns).index("Taxa de Administração")
        colunas_proprietarios = list(df.columns)[idx_valor_total+1:idx_taxa_adm]
        registros_processados = 0
        registros_sucesso = 0
        registros_erros = 0
        erros_detalhe = []
        for indice, fila in df.iterrows():
            registros_processados += 1
            try:
                nome_imovel = str(fila[primeira_coluna]).strip()
                valor_total = fila["Valor Total"]
                taxa_administracao = fila["Taxa de Administração"]
                if pd.isna(valor_total) or valor_total == 0:
                    erros_detalhe.append(f"Linha {indice + 2}: Valor total vazio ou zero")
                    registros_erros += 1
                    continue
                imovel = db.query(Imovel).filter(Imovel.nome == nome_imovel).first()
                if not imovel:
                    erros_detalhe.append(f"Linha {indice + 2}: Imóvel '{nome_imovel}' não encontrado")
                    registros_erros += 1
                    continue
                try:
                    if isinstance(fila[primeira_coluna], pd.Timestamp):
                        data_ref = fila[primeira_coluna]
                    else:
                        data_ref = pd.to_datetime(fila[primeira_coluna])
                    mes = data_ref.month
                    ano = data_ref.year
                except Exception:
                    data_atual = datetime.now()
                    mes = data_atual.month
                    ano = data_atual.year
                for col_prop in colunas_proprietarios:
                    valor_prop = fila[col_prop]
                    if pd.notna(valor_prop) and valor_prop != 0:
                        nome_prop = col_prop.strip().lower()
                        propietario = proprietarios_map.get(nome_prop)
                        if not propietario:
                            erros_detalhe.append(f"Linha {indice + 2}: Proprietário '{col_prop}' não encontrado na base")
                            registros_erros += 1
                            continue
                        existe = db.query(AluguelSimples).filter(
                            and_(
                                AluguelSimples.imovel_id == imovel.id,
                                AluguelSimples.proprietario_id == propietario.id,
                                AluguelSimples.mes == mes,
                                AluguelSimples.ano == ano
                            )
                        ).first()
                        if existe:
                            erros_detalhe.append(f"Linha {indice + 2}: Registro duplicado para {col_prop} em {mes}/{ano}")
                            continue
                        novo_aluguel = AluguelSimples(
                            imovel_id=imovel.id,
                            proprietario_id=propietario.id,
                            nome_imovel=imovel.nome,
                            nome_proprietario=propietario.nome,
                            mes=mes,
                            ano=ano,
                            valor_aluguel_proprietario=valor_prop,
                            taxa_administracao_total=taxa_administracao if pd.notna(taxa_administracao) else 0,
                            taxa_administracao_proprietario=0,
                            valor_liquido_proprietario=valor_prop
                        )
                        db.add(novo_aluguel)
                        registros_sucesso += 1
            except Exception as e:
                registros_erros += 1
                erros_detalhe.append(f"Linha {indice + 2}: Erro inesperado - {str(e)}")
        db.commit()
        return {
            "processados": registros_processados,
            "sucesso": registros_sucesso,
            "erros": registros_erros,
            "detalhe_erros": erros_detalhe[:10]
        }
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Erro ao processar arquivo: {str(e)}")

@router.get("/logs/importacoes")
async def logs_importacoes(skip: int = Query(0, ge=0), limit: int = Query(50, ge=1, le=100), db: Session = Depends(get_db)):
    """Endpoint para logs de importações (placeholder)."""
    return []
"""
Router para endpoints de importação Excel
"""
import os
import pandas as pd
import traceback
from datetime import datetime
from fastapi import APIRouter, HTTPException, UploadFile, File, Query, Depends
from sqlalchemy import and_, text, desc
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError
from config import get_db
from models_final import AluguelSimples, Proprietario, Imovel
from services.calculo_service import CalculoService

router = APIRouter(tags=["importação"])

@router.post("/importar-excel/")
async def importar_excel(file: UploadFile = File(...), db: Session = Depends(get_db)):
    """Importar proprietários a partir de arquivo Excel"""
    if not file.filename.endswith((".xlsx", ".xls")):
        raise HTTPException(status_code=400, detail="O arquivo deve ser Excel (.xlsx ou .xls)")

    inicio_tempo = datetime.now()

    try:
        contents = await file.read()
        df = pd.read_excel(contents)

        registros_processados = 0
        registros_sucesso = 0
        registros_erros = 0
        erros_detalhe = []

        for indice, fila in df.iterrows():
            registros_processados += 1
            try:
                dados = fila.to_dict()
                novo_proprietario = Proprietario(
                    nome=dados.get('Nome', ''),
                    sobrenome=dados.get('Sobrenome', ''),
                    documento=dados.get('Documento', ''),
                    tipo_documento=dados.get('TipoDocumento', ''),
                    endereco=dados.get('Endereco', ''),
                    telefone=dados.get('Telefone', ''),
                    email=dados.get('Email', ''),
                    banco=dados.get('Banco', ''),
                    agencia=dados.get('Agencia', ''),
                    conta=dados.get('Conta', ''),
                    tipo_conta=dados.get('TipoConta', '')
                )
                db.add(novo_proprietario)
                db.flush()
                registros_sucesso += 1
            except Exception as e:
                registros_erros += 1
                erros_detalhe.append(f"Linha {indice + 2}: Erro - {str(e)}")

        db.commit()

        tempo_total = datetime.now() - inicio_tempo
        resultado = {
            "processados": registros_processados,
            "sucesso": registros_sucesso,
            "erros": registros_erros,
            "detalhe_erros": erros_detalhe[:10] if len(erros_detalhe) > 10 else erros_detalhe,
            "mensagem": f"Processados: {registros_processados}, Sucesso: {registros_sucesso}, Erros: {registros_erros}",
            "tempo_processamento": str(tempo_total)
        }
        return resultado
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Erro ao processar arquivo: {str(e)}")

@router.post("/cargar-base2025/")
async def cargar_base2025(db: Session = Depends(get_db)):
    """Cargar propietarios desde archivo Base2025.xlsx"""
    archivo_path = "/home/mloco/Escritorio/SistemaAlquileresV2/Base2025.xlsx"
    if not os.path.exists(archivo_path):
        raise HTTPException(status_code=404, detail="Archivo Base2025.xlsx no encontrado")
    try:
        df = pd.read_excel(archivo_path)
        registros_procesados, registros_exitosos, registros_errores = 0, 0, 0
        errores_detalle = []
        columnas_propietarios = df.columns[3:].tolist()
        batch_size = 50
        batch_count = 0
        for indice, fila in df.iterrows():
            if pd.isna(fila["NOMBRE"]):
                continue
            nombre_propiedad = str(fila["NOMBRE"]).strip()
            if not nombre_propiedad:
                continue
            registros_procesados += 1
            for col_propietario in columnas_propietarios:
                porcentaje = fila[col_propietario]
                if pd.notna(porcentaje) and porcentaje > 0:
                    try:
                            valor_alquiler = 2000.0 * porcentaje
                            novo_aluguel = AluguelSimples(
                                nome_imovel=nombre_propiedad,
                                mes=7,
                                ano=2025,
                                nome_proprietario=col_propietario.strip(),
                                valor_aluguel_proprietario=round(float(valor_alquiler), 2),
                                taxa_administracao_total=200.0,
                                observacoes=f"Base2025.xlsx - {porcentaje*100:.1f}%"
                            )
                        db.add(novo_aluguel)
                        registros_exitosos += 1
                        batch_count += 1
                        if batch_count >= batch_size:
                            db.commit()
                            batch_count = 0
                    except Exception as e:
                        registros_errores += 1
                        errores_detalle.append(f"{nombre_propiedad} - {col_propietario}: {str(e)}")
        if batch_count > 0:
            db.commit()
        periodos_unicos = set()
        for indice, fila in df.iterrows():
            if pd.isna(fila["NOMBRE"]):
                continue
            nombre_propiedad = str(fila["NOMBRE"]).strip()
            if nombre_propiedad:
                periodos_unicos.add((nombre_propiedad, 7, 2025))
        for propiedad, mes, ano in periodos_unicos:
            try:
                CalculoService.calcular_tasas_administracion_propietario(db, propiedad, mes, ano)
            except Exception as e:
                errores_detalle.append(f"Error calculando tasas para {propiedad}: {str(e)}")
        return {
            "mensaje": "Base2025.xlsx procesado exitosamente",
            "resumen": {
                "registros_procesados": registros_procesados,
                "registros_exitosos": registros_exitosos,
                "registros_errores": registros_errores,
                "propietarios_encontrados": len(columnas_propietarios)
            }
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error: {str(e)}")

@router.get("/logs/importaciones")
async def logs_importaciones(
    skip: int = Query(0, ge=0),
    limit: int = Query(50, ge=1, le=100),
    db: Session = Depends(get_db)
):
    """Obtener logs de importações"""
    return []

@router.post("/importar-alquileres-modelo/")
async def importar_alquileres_modelo(file: UploadFile = File(...), db: Session = Depends(get_db)):
    """Importa aluguéis a partir de arquivo Excel com nomes reais de proprietários."""
    if not file.filename.endswith((".xlsx", ".xls")):
        raise HTTPException(status_code=400, detail="Arquivo deve ser Excel (.xlsx ou .xls)")

    inicio_tempo = datetime.now()

    try:
        conteudo = await file.read()
        df = pd.read_excel(conteudo)

        colunas_esperadas = ["Valor Total", "Taxa de Administração"]
        for col in colunas_esperadas:
            if col not in df.columns:
                raise HTTPException(status_code=400, detail=f"Coluna '{col}' obrigatória não encontrada. Colunas disponíveis: {list(df.columns)}")

        primeira_coluna = df.columns[0]
        proprietarios_bd = db.query(Proprietario).all()
        proprietarios_map = {p.nome.strip().lower(): p for p in proprietarios_bd}

        idx_valor_total = list(df.columns).index("Valor Total")
        idx_taxa_adm = list(df.columns).index("Taxa de Administração")
        colunas_proprietarios = list(df.columns)[idx_valor_total+1:idx_taxa_adm]

        registros_procesados = 0
        registros_exitosos = 0
        registros_errores = 0
        erros_detalhe = []

        for indice, fila in df.iterrows():
            registros_procesados += 1
            try:
                nome_imovel = str(fila[primeira_coluna]).strip()
                valor_total = fila["Valor Total"]
                taxa_administracao = fila["Taxa de Administração"]

                if pd.isna(valor_total) or valor_total == 0:
                    erros_detalhe.append(f"Linha {indice + 2}: Valor total vazio ou zero")
                    registros_errores += 1
                    continue

                imovel = db.query(Imovel).filter(Imovel.nome == nome_imovel).first()
                if not imovel:
                    erros_detalhe.append(f"Linha {indice + 2}: Imóvel '{nome_imovel}' não encontrado")
                    registros_errores += 1
                    continue

                try:
                    if isinstance(fila[primeira_coluna], pd.Timestamp):
                        data_ref = fila[primeira_coluna]
                    else:
                        data_ref = pd.to_datetime(fila[primeira_coluna])
                    mes = data_ref.month
                    ano = data_ref.year
                except Exception:
                    data_atual = datetime.now()
                    mes = data_atual.month
                    ano = data_atual.year

                for col_prop in colunas_proprietarios:
                    valor_prop = fila[col_prop]
                    if pd.notna(valor_prop) and valor_prop != 0:
                        nome_prop = col_prop.strip().lower()
                        propietario = proprietarios_map.get(nome_prop)
                        if not propietario:
                            erros_detalhe.append(f"Linha {indice + 2}: Proprietário '{col_prop}' não encontrado na base")
                            registros_errores += 1
                            continue
                        existe = db.query(AluguelSimples).filter(
                            and_(
                                AluguelSimples.imovel_id == imovel.id,
                                AluguelSimples.proprietario_id == propietario.id,
                                AluguelSimples.mes == mes,
                                AluguelSimples.ano == ano
                            )
                        ).first()
                        if existe:
                            erros_detalhe.append(f"Linha {indice + 2}: Registro duplicado para {col_prop} em {mes}/{ano}")
                            continue
                        novo_aluguel = AluguelSimples(
                            imovel_id=imovel.id,
                            proprietario_id=propietario.id,
                            nome_imovel=imovel.nome,
                            nome_proprietario=propietario.nome,
                            mes=mes,
                            ano=ano,
                            valor_aluguel_proprietario=valor_prop,
                            taxa_administracao_total=taxa_administracao if pd.notna(taxa_administracao) else 0,
                            taxa_administracao_proprietario=0,
                            valor_liquido_proprietario=valor_prop
                        )
                        db.add(novo_aluguel)
                        registros_exitosos += 1
            except Exception as e:
                registros_errores += 1
                erros_detalhe.append(f"Linha {indice + 2}: Erro inesperado - {str(e)}")

        db.commit()

        tempo_total = datetime.now() - inicio_tiempo
        resultado = {
            "procesados": registros_procesados,
            "exitosos": registros_exitosos,
            "erros": registros_errores,
            "detalhe_erros": erros_detalhe[:10],
            "mensagem": f"Procesados: {registros_procesados}, Exitosos: {registros_exitosos}, Erros: {registros_errores}",
            "tempo_processamento": str(tempo_total)
        }
        return resultado
    except Exception as e:
        db.rollback()
        import traceback
        print(f"Erro na importação de aluguéis: {traceback.format_exc()}")
        raise HTTPException(status_code=500, detail=f"Erro ao processar arquivo: {str(e)}")
"""
Router para endpoints de importación Excel
"""
import os
import pandas as pd
import traceback
from datetime import datetime
from fastapi import APIRouter, HTTPException, UploadFile, File, Query, Depends
    # Criar log de importação (temporariamente desabilitado)
    # log_import = LogImportacionSimple(
    #     nome_arquivo=file.filename,
    #     estado="PROCESSANDO"
    # )
    # db.add(log_import)
    # db.commit()y.orm import Session
from sqlalchemy import and_, text, desc
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError

from config import get_db

@router.post("/importar-alquileres-modelo/")
async def importar_alquileres_modelo(file: UploadFile = File(...), db: Session = Depends(get_db)):
    """Importa aluguéis a partir de arquivo Excel com nomes reais de proprietários."""
    if not file.filename.endswith((".xlsx", ".xls")):
        raise HTTPException(status_code=400, detail="Arquivo deve ser Excel (.xlsx ou .xls)")

    inicio_tempo = datetime.now()

    # Criar log de importação
    log_import = LogImportacionSimple(
        nome_arquivo=file.filename,
        estado="PROCESSANDO"
    )
    db.add(log_import)
    db.commit()
    db.refresh(log_import)

    try:
        conteudo = await file.read()
        df = pd.read_excel(conteudo)

        # Verificar colunas obrigatórias
        colunas_esperadas = ["Valor Total", "Taxa de Administração"]
        for col in colunas_esperadas:
            if col not in df.columns:
                raise HTTPException(status_code=400, detail=f"Coluna '{col}' obrigatória não encontrada. Colunas disponíveis: {list(df.columns)}")

        primeira_coluna = df.columns[0]
        proprietarios_bd = db.query(Proprietario).all()
        proprietarios_map = {p.nome.strip().lower(): p for p in proprietarios_bd}

        idx_valor_total = list(df.columns).index("Valor Total")
        idx_taxa_adm = list(df.columns).index("Taxa de Administração")
        colunas_proprietarios = list(df.columns)[idx_valor_total+1:idx_taxa_adm]

        registros_procesados = 0
        registros_exitosos = 0
        registros_errores = 0
        erros_detalhe = []

        for indice, fila in df.iterrows():
            registros_procesados += 1
            try:
                nome_imovel = str(fila[primeira_coluna]).strip()
                valor_total = fila["Valor Total"]
                taxa_administracao = fila["Taxa de Administração"]

                if pd.isna(valor_total) or valor_total == 0:
                    erros_detalhe.append(f"Linha {indice + 2}: Valor total vazio ou zero")
                    registros_errores += 1
                    continue

                imovel = db.query(Imovel).filter(Imovel.nome == nome_imovel).first()
                if not imovel:
                    erros_detalhe.append(f"Linha {indice + 2}: Imóvel '{nome_imovel}' não encontrado")
                    registros_errores += 1
                    continue

                # Extrair mês e ano da data
                try:
                    if isinstance(fila[primeira_coluna], pd.Timestamp):
                        data_ref = fila[primeira_coluna]
                    else:
                        data_ref = pd.to_datetime(fila[primeira_coluna])
                    mes = data_ref.month
                    ano = data_ref.year
                except Exception:
                    data_atual = datetime.now()
                    mes = data_atual.month
                    ano = data_atual.year

                for col_prop in colunas_proprietarios:
                    valor_prop = fila[col_prop]
                    if pd.notna(valor_prop) and valor_prop != 0:
                        nome_prop = col_prop.strip().lower()
                        propietario = proprietarios_map.get(nome_prop)
                        if not propietario:
                            erros_detalhe.append(f"Linha {indice + 2}: Proprietário '{col_prop}' não encontrado na base")
                            registros_errores += 1
                            continue
                        existe = db.query(AluguelSimples).filter(
                            and_(
                                AluguelSimples.imovel_id == imovel.id,
                                AluguelSimples.proprietario_id == propietario.id,
                                AluguelSimples.mes == mes,
                                AluguelSimples.ano == ano
                            )
                        ).first()
                        if existe:
                            erros_detalhe.append(f"Linha {indice + 2}: Registro duplicado para {col_prop} em {mes}/{ano}")
                            continue
                        novo_aluguel = AluguelSimples(
                            imovel_id=imovel.id,
                            proprietario_id=propietario.id,
                            nome_imovel=imovel.nome,
                            nome_proprietario=propietario.nome,
                            mes=mes,
                            ano=ano,
                            valor_aluguel_proprietario=valor_prop,
                            taxa_administracao_total=taxa_administracao if pd.notna(taxa_administracao) else 0,
                            taxa_administracao_proprietario=0,
                            valor_liquido_proprietario=valor_prop
                        )
                        db.add(novo_aluguel)
                        registros_exitosos += 1
            except Exception as e:
                registros_errores += 1
                erros_detalhe.append(f"Linha {indice + 2}: Erro inesperado - {str(e)}")

        db.commit()

        tempo_total = datetime.now() - inicio_tiempo
        log_import.estado = "COMPLETADO"
        log_import.registros_processados = registros_procesados
        log_import.registros_exitosos = registros_exitosos
        log_import.registros_errores = registros_errores
        log_import.tempo_processamento = str(tempo_total)
        db.commit()

        resultado = {
            "procesados": registros_procesados,
            "exitosos": registros_exitosos,
            "erros": registros_errores,
            "detalhe_erros": erros_detalhe[:10],
            "mensagem": f"Procesados: {registros_procesados}, Exitosos: {registros_exitosos}, Erros: {registros_errores}",
            "tempo_processamento": str(tempo_total)
        }
        return resultado
    except Exception as e:
        db.rollback()
        log_import.estado = "ERROR"
        log_import.observacoes = str(e)
        db.commit()
        import traceback
        print(f"Erro na importação de aluguéis: {traceback.format_exc()}")
        raise HTTPException(status_code=500, detail=f"Erro ao processar arquivo: {str(e)}")
                            observaciones=f"Base2025.xlsx - {porcentaje*100:.1f}%"
                        )
                        db.add(nuevo_alquiler)
                        registros_exitosos += 1
                        batch_count += 1
                        
                        # Commit cada 50 registros
                        if batch_count >= batch_size:
                            db.commit()
                            batch_count = 0
                    except Exception as e:
                        registros_errores += 1
                        errores_detalle.append(f"{nombre_propiedad} - {col_propietario}: {str(e)}")
        
        # Commit final para los registros restantes
        if batch_count > 0:
            db.commit()
            
        # Recalcular tasas para julio 2025 (período de Base2025)
        periodos_unicos = set()
        for indice, fila in df.iterrows():
            if pd.isna(fila["NOMBRE"]): continue
            nombre_propiedad = str(fila["NOMBRE"]).strip()
            if nombre_propiedad:
                periodos_unicos.add((nombre_propiedad, 7, 2025))
        
        for propiedad, mes, ano in periodos_unicos:
            try:
                CalculoService.calcular_tasas_administracion_propietario(db, propiedad, mes, ano)
            except Exception as e:
                errores_detalle.append(f"Error calculando tasas para {propiedad}: {str(e)}")
            
        return {
            "mensaje": "Base2025.xlsx procesado exitosamente",
            "resumen": {
                "registros_procesados": registros_procesados,
                "registros_exitosos": registros_exitosos,
                "registros_errores": registros_errores,
                "propietarios_encontrados": len(columnas_propietarios)
            }
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error: {str(e)}")

@router.get("/logs/importaciones")
async def logs_importaciones(
    skip: int = Query(0, ge=0),
    limit: int = Query(50, ge=1, le=100),
    db: Session = Depends(get_db)
):
    """Obtener logs de importações"""
    # logs = db.query(LogImportacionSimple)\
    #     .order_by(desc(LogImportacionSimple.fecha_importacion))\
    #     .offset(skip).limit(limit).all()
    
    # return [log.to_dict() for log in logs]
    return []  # Temporariamente vazio até implementar logs

@router.post("/importar-alquileres-modelo/")
async def importar_alquileres_modelo(file: UploadFile = File(...), db: Session = Depends(get_db)):
    """Importar alquileres desde archivo Excel según ModeloAlquileres.xlsx"""
    if not file.filename.endswith(('.xlsx', '.xls')):
        raise HTTPException(status_code=400, detail="Archivo debe ser Excel (.xlsx o .xls)")
    
    inicio_tiempo = datetime.now()
    
    # Crear log de importación
    log_import = LogImportacionSimple(
        nombre_archivo=file.filename,
        estado="PROCESANDO"
    )
    db.add(log_import)
    # Commit já está dentro do fluxo correto, não deve estar fora de bloco try/except/finally
    db.refresh(log_import)
    
    try:
        # Leer archivo Excel
        contenido = await file.read()
        df = pd.read_excel(contenido)
        
        # Verificar estructura según ModeloAlquileres.xlsx
        # Primera columna debe ser fecha, segunda "Valor Total", luego propietarios Nnnn1-10, última "Taxa de Administração"
        # Verificar estrutura básica
        columnas_esperadas = ['Valor Total', 'Taxa de Administração']
        for col in columnas_esperadas:
            if col not in df.columns:
                raise HTTPException(
                    status_code=400,
                    detail=f"Coluna '{col}' obrigatória não encontrada. Colunas disponíveis: {list(df.columns)}"
                )
        primeira_coluna = df.columns[0]
        proprietarios_bd = db.query(Proprietario).all()
        proprietarios_map = {p.nome.strip().lower(): p for p in proprietarios_bd}
        registros_procesados = 0
        registros_exitosos = 0
        registros_errores = 0
        errores_detalle = []
        # Identificar colunas de proprietários (todas entre 'Valor Total' e 'Taxa de Administração')
        idx_valor_total = list(df.columns).index('Valor Total')
        idx_taxa_adm = list(df.columns).index('Taxa de Administração')
        colunas_proprietarios = list(df.columns)[idx_valor_total+1:idx_taxa_adm]
        for indice, fila in df.iterrows():
            registros_procesados += 1
            try:
                nome_imovel = str(fila[primeira_coluna]).strip()
                valor_total = fila['Valor Total']
                taxa_administracao = fila['Taxa de Administração']
                if pd.isna(valor_total) or valor_total == 0:
                    errores_detalle.append(f"Linha {indice + 2}: Valor total vazio ou zero")
                    registros_errores += 1
                    continue
                imovel = db.query(Imovel).filter(Imovel.nome == nome_imovel).first()
                if not imovel:
                    errores_detalle.append(f"Linha {indice + 2}: Imóvel '{nome_imovel}' não encontrado")
                    registros_errores += 1
                    continue
                # Extrair mês e ano da data
                try:
                    if isinstance(fila[primeira_coluna], pd.Timestamp):
                        data_ref = fila[primeira_coluna]
                    else:
                        data_ref = pd.to_datetime(fila[primeira_coluna])
                    mes = data_ref.month
                    ano = data_ref.year
                except:
                    data_atual = datetime.now()
                    mes = data_atual.month
                    ano = data_atual.year
                # Processar cada proprietário real
                for col_prop in colunas_proprietarios:
                    valor_prop = fila[col_prop]
                    if pd.notna(valor_prop) and valor_prop != 0:
                        nome_prop = col_prop.strip().lower()
                        propietario = proprietarios_map.get(nome_prop)
                        if not propietario:
                            errores_detalle.append(f"Linha {indice + 2}: Proprietário '{col_prop}' não encontrado na base")
                            registros_errores += 1
                            continue
                        # Verificar duplicidade
                        existe = db.query(AluguelSimples).filter(
                            and_(
                                AluguelSimples.imovel_id == imovel.id,
                                AluguelSimples.proprietario_id == propietario.id,
                                AluguelSimples.mes == mes,
                                AluguelSimples.ano == ano
                            )
                        ).first()
                        if existe:
                            errores_detalle.append(f"Linha {indice + 2}: Registro duplicado para {col_prop} em {mes}/{ano}")
                            continue
                        novo_aluguel = AluguelSimples(
                            imovel_id=imovel.id,
                            proprietario_id=propietario.id,
                            nome_imovel=imovel.nome,
                            nome_proprietario=propietario.nome,
                            mes=mes,
                            ano=ano,
                            valor_aluguel_proprietario=valor_prop,
                            taxa_administracao_total=taxa_administracao if pd.notna(taxa_administracao) else 0,
                            taxa_administracao_proprietario=0,
                            valor_liquido_proprietario=valor_prop
                        )
                        db.add(novo_aluguel)
                        registros_exitosos += 1
            except Exception as e:
                registros_errores += 1
                errores_detalle.append(f"Linha {indice + 2}: Erro inesperado - {str(e)}")
        db.commit()
                                                        mes=mes,
                                                        ano=ano,
                                                        valor_aluguel_proprietario=valor_prop,
                                                        taxa_administracao_total=taxa_administracao if pd.notna(taxa_administracao) else 0,
                                                        taxa_administracao_proprietario=0,
                                                        valor_liquido_proprietario=valor_prop
                                                    )
                                                    db.add(novo_aluguel)
                                                    registros_exitosos += 1
                                        except Exception as e:
                                            registros_errores += 1
                                            errores_detalle.append(f"Linha {indice + 2}: Erro inesperado - {str(e)}")
                                    # db.commit() removido para corrigir erro de sintaxe
